<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Frogzart Flappy ‚Äî Night + Bach</title>
<meta name="theme-color" content="#0b1736" />
<style>
  html,body{margin:0;height:100%;background:#0b1736}
  body{display:grid;place-items:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  canvas{width:100vw;height:100vh;background:#0b1736;image-rendering:pixelated;image-rendering:crisp-edges;touch-action:manipulation}
  #ui{position:fixed;inset:0;pointer-events:none;display:flex;align-items:flex-start;justify-content:center}
  #scoreLive{margin-top:10px;background:rgba(255,255,255,.9);padding:.35rem .7rem;border-radius:999px;font-weight:900;letter-spacing:.5px;box-shadow:0 2px 10px #0002}
  #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.25);backdrop-filter:blur(4px)}
  .card{width:min(92vw,520px);background:#0f1a3e;color:#e9f0ff;padding:18px;border-radius:16px;border:1px solid #223064;box-shadow:0 20px 56px #0006}
  .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:.8rem;justify-content:center}
  button{appearance:none;border:0;border-radius:12px;background:linear-gradient(180deg,#3fe08b,#2bb673);padding:.7rem 1rem;font-weight:900;color:#053b2a;cursor:pointer;pointer-events:auto}
  small{opacity:.85}
</style>
</head>
<body>
<canvas id="c" width="720" height="1280" aria-label="Frogzart Flappy ‚Äî Night + Bach"></canvas>

<div id="ui"><div id="scoreLive">0</div></div>
<div id="overlay">
  <div class="card" id="ovCard">
    <h2>üê∏üéº Frogzart Flappy ‚Äî Night Sky</h2>
    <p>Tap anywhere (or press <b>Space</b>) to flap. Fly through the dark-green pipe gaps to score. Some pipes move slowly‚Äîalways fair.</p>
    <div class="row">
      <button id="play">Play</button>
    </div>
    <p class="row" style="justify-content:space-between;margin:10px 0 0">
      <span>Best: <b id="best">0</b></span>
      <span><small>Tip: short, steady taps work best.</small></span>
    </p>
  </div>
</div>

<script>
/* ===================== Setup ===================== */
const W = 720, H = 1280;
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d', {alpha:false});
ctx.imageSmoothingEnabled = false;

const frogImg = new Image();
frogImg.src = 'frogzart.png';

/* ===================== Game State ===================== */
const G = 0.45;
const FLAP = -9.6;
const GAP = 300;              // fixed gap height
const PIPE_W = 160;
const DIST = 420;
const GROUND_H = 120;
const BASE_SPD = 3.2;
const SPD_PER_PT = 0.06;
const MAX_ROT = 0.5;

// Moving pipes
const MOVE_AFTER = 3;
const MOVE_CHANCE = 0.55;
const MOVE_AMP = 40;
const MOVE_SPEED = 0.01;

// Safe bounds for gap center
const SAFE_MARGIN = 110;
const SAFE_TOP = SAFE_MARGIN;
const SAFE_BOTTOM = H - GROUND_H - SAFE_MARGIN;

let state='ready';
let speed = BASE_SPD;
let pipes = [];
let stars = [];
let puffs = [];
let score = 0;
let best = +localStorage.fz_flappy_night_bach_best || 0;
let t=0;

const bird = { x: W*0.32, y: H*0.48, vx:0, vy:0, w:110, h:110, rot:0 };
document.getElementById('best').textContent = best;

/* ===================== Audio ‚Äî Bach Prelude in C (public domain) ===================== */
/* Simplified arpeggiated pattern (looped) based on the opening progression. */
const AudioKit=(()=>{
  let ac, master, sfxG, musicG, loop=null, bpm=84, baseBPM=84, maxBPM=116, step=0;

  // Utility
  const NOTE=(n)=>440*Math.pow(2,(n-69)/12); // MIDI->Hz

  // Chord progression (approx. first 8 bars): C, G/B, Am7, G, Fmaj7, C/E, Dm7, G7
  // Each "bar" uses the same broken-chord picking order indices into the chord tones below.
  const chords = [
    [60,64,67,72],     // C  : C E G C
    [59,62,67,71],     // G/B: B D G B
    [57,60,64,69],     // Am7: A C E G
    [55,59,62,67],     // G  : G B D G
    [53,57,60,65],     // Fmaj7: F A C E
    [52,55,60,64],     // C/E: E G C E
    [50,53,57,62],     // Dm7: D F A C
    [55,59,62,67]      // G7 : G B D F (approx)
  ];
  // Picking pattern (8 notes per bar, repeating)
  const pick = [0,1,2,1,3,2,1,2]; // classic flowing arpeggio feel

  function init(){ if(ac) return;
    ac = new (window.AudioContext||window.webkitAudioContext)();
    master = ac.createGain(); master.gain.value = 1; master.connect(ac.destination);
    sfxG = ac.createGain(); sfxG.gain.value = 0.9; sfxG.connect(master);
    musicG = ac.createGain(); musicG.gain.value = 0.20; musicG.connect(master);
  }
  function pluck(freq, dur, gain, pan=0){
    const t0 = ac.currentTime;
    const o = ac.createOscillator();
    const g = ac.createGain();
    const p = ac.createStereoPanner ? ac.createStereoPanner() : null;
    o.type='triangle'; o.frequency.value=freq;
    g.gain.value=0; g.gain.linearRampToValueAtTime(gain, t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
    if(p){ p.pan.value = pan; o.connect(g); g.connect(p); p.connect(musicG); } else { o.connect(g); g.connect(musicG); }
    o.start(t0); o.stop(t0+dur+0.02);
  }
  function flap(){ pluck(160,0.08,.55); pluck(240,0.06,.35); } // low boop + fifth
  function point(){ pluck(1200,0.05,.4); }
  function hit(){ pluck(400,0.09,.5); setTimeout(()=>pluck(250,0.14,.45),70); }

  function startMusic(){
    stopMusic(); step=0;
    const tick=()=>{
      const bar = Math.floor(step/8) % chords.length;
      const idx = pick[step % 8];
      const midi = chords[bar][idx];
      const freq = NOTE(midi);
      const secPerBeat = 60/bpm;
      // gentle stereo sway
      const pan = Math.sin(step*0.25)*0.2;
      pluck(freq, secPerBeat*0.9, 0.065, pan);
      step++;
      loop = setTimeout(tick, 1000*secPerBeat);
    };
    tick();
  }
  function stopMusic(){ if(loop){ clearTimeout(loop); loop=null; } }
  function setTempoForScore(sc){
    // subtle ramp: +2 BPM per point up to max
    bpm = Math.min(maxBPM, baseBPM + sc*2);
  }
  return {init,flap,point,hit,startMusic,stopMusic,setTempoForScore};
})();

/* ===================== Night Stars (even slower & calmer) ===================== */
function rnd(a,b){ return a + Math.random()*(b-a); }
function spawnStars(){
  stars.length=0;
  const layers = [
    {count: 24, spd: -0.05, size:[1,2],   alpha:[0.45,0.8]},  // far
    {count: 18, spd: -0.10, size:[1.3,2.3], alpha:[0.55,0.9]},// mid
    {count: 12, spd: -0.16, size:[1.8,3.0], alpha:[0.6,1.0]}  // near
  ];
  layers.forEach((L,i)=>{
    for(let k=0;k<L.count;k++){
      stars.push({
        x: rnd(-W*0.15, W*1.05),
        y: rnd(20, H-180),
        r: rnd(L.size[0], L.size[1]),
        spd: L.spd,
        a: rnd(L.alpha[0], L.alpha[1]),
        tw: Math.random()*Math.PI*2,
        twSpd: 0.006 + i*0.003, // slower twinkle
        layer:i
      });
    }
  });
}
function updateStars(dt){
  for(const s of stars){
    s.x += s.spd * dt * 60;
    s.tw += s.twSpd * (dt*60/60);
    if(s.x < -20) { s.x = W + rnd(10,120); s.y = rnd(20, H-180); }
  }
}
function drawStar(s){
  const twinkle = 0.18*Math.sin(s.tw) + 0.82;
  ctx.save();
  ctx.globalAlpha = Math.max(0, Math.min(1, s.a * twinkle));
  ctx.fillStyle = '#ffffff';
  ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha *= 0.3;
  ctx.fillRect(s.x-0.6, s.y-2.2*s.r, 1.2, 4.4*s.r);
  ctx.fillRect(s.x-2.2*s.r, s.y-0.6, 4.4*s.r, 1.2);
  ctx.restore();
}

/* ===================== Pipes (with clefs, fixed-size gaps, fair positions) ===================== */
let spawnCount = 0;
function spawnPipePair(x){
  const minCenter = SAFE_TOP + GAP/2;
  const maxCenter = SAFE_BOTTOM - GAP/2;
  const gapCenter = rnd(minCenter, maxCenter); // random, constant gap
  const moving = (spawnCount++ >= MOVE_AFTER) && Math.random() < MOVE_CHANCE;
  const phase = Math.random() * Math.PI * 2;
  // random clef assignment for variety per pair
  const topClef = Math.random()<0.7 ? 'treble' : 'bass';
  const botClef = Math.random()<0.7 ? 'bass' : 'treble';
  pipes.push({x, w:PIPE_W, baseGap:gapCenter, gap:gapCenter, passed:false, moving, phase, topClef, botClef});
}
function resetPipes(){
  pipes.length=0; spawnCount=0;
  let x=W+600;
  for(let i=0;i<4;i++){ spawnPipePair(x); x += DIST; }
}
function updatePipeMotion(p){
  if(!p.moving) return;
  p.phase += MOVE_SPEED;
  const center = p.baseGap + Math.sin(p.phase)*MOVE_AMP;
  const minCenter = SAFE_TOP + GAP/2;
  const maxCenter = SAFE_BOTTOM - GAP/2;
  p.gap = Math.max(minCenter, Math.min(maxCenter, center));
}
/* Dark-green pipe drawn EXACTLY to rect (visual == collision) */
function drawPipeExact(x, y, w, h, capAtBottom){
  if(h<=0) return;
  const g = ctx.createLinearGradient(x, y, x+w, y+h);
  g.addColorStop(0,  '#166b20');
  g.addColorStop(0.5,'#0f5a1a');
  g.addColorStop(1,  '#0b4a15');
  ctx.fillStyle = g; ctx.strokeStyle = '#083a10'; ctx.lineWidth = 3;
  ctx.fillRect(x, y, w, h);
  ctx.strokeRect(x+0.5, y+0.5, w-1, h-1);
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fillRect(x+6, y+6, 10, Math.max(0,h-12));
  const capH = Math.min(34, h);
  ctx.fillStyle = '#1a7d27'; ctx.strokeStyle = '#0c5a18';
  if(capAtBottom){ ctx.fillRect(x, y + h - capH, w, capH); ctx.strokeRect(x+0.5, y + h - capH + 0.5, w-1, capH-1); }
  else{ ctx.fillRect(x, y, w, capH); ctx.strokeRect(x+0.5, y+0.5, w-1, capH-1); }
}
/* Clefs on pipes (never drawn into the gap) */
function drawClefOnRect(x,y,w,h,type){
  if(h<40) return; // tiny pipes near bounds‚Äîskip
  // Try Unicode music symbols with common fallbacks
  const symbol = type==='treble' ? 'ùÑû' : 'ùÑ¢'; // U+1D11E / U+1D122
  ctx.save();
  ctx.fillStyle='rgba(255,255,255,0.9)';
  // pick a size that fits inside the pipe nicely
  const fontSize = Math.max(28, Math.min(64, h*0.35));
  ctx.font = `${fontSize}px "Noto Music","Apple Symbols","Segoe UI Symbol",serif`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  // position centered within the given rect, with slight vertical bias away from edges
  const cx = x + w/2;
  const cy = y + h/2 + (type==='treble' ? -4 : 4);
  ctx.fillText(symbol, cx, cy);
  ctx.restore();
}

/* ===================== Input ===================== */
function flap(){
  if(state==='ready'){ start(); }
  if(state!=='playing') return;
  bird.vy = FLAP;
  AudioKit.flap();
  for(let i=0;i<2;i++){
    puffs.push({x:bird.x-30+rnd(-6,6), y:bird.y+rnd(-8,8), vx:rnd(-0.8,-0.2), vy:rnd(-0.3,0.3), a:1, r:rnd(3,5)});
  }
}
window.addEventListener('keydown',e=>{ if(e.code==='Space'){ e.preventDefault(); flap(); }});
cvs.addEventListener('pointerdown', flap, {passive:true});

document.getElementById('play').addEventListener('click', ()=>{
  document.getElementById('overlay').style.display='none';
  AudioKit.init(); AudioKit.startMusic();
  start(true);
});

/* ===================== Game Flow ===================== */
function start(){
  state='playing';
  score=0; speed=BASE_SPD;
  bird.x=W*0.32; bird.y=H*0.48; bird.vy=0; bird.rot=0;
  resetPipes();
  spawnStars();
  document.getElementById('scoreLive').textContent = score;
}
function gameOver(){
  state='dead';
  AudioKit.hit(); AudioKit.stopMusic();
  best = Math.max(best, score); localStorage.fz_flappy_night_bach_best = best;
  document.getElementById('best').textContent = best;
  setTimeout(()=>{
    document.getElementById('overlay').style.display='flex';
    document.getElementById('ovCard').querySelector('h2').innerHTML = 'Encore next time!';
    document.getElementById('ovCard').querySelector('p').innerHTML = `Score: <b>${score}</b> &nbsp; ‚Ä¢ &nbsp; Best: <b>${best}</b>`;
    document.getElementById('play').textContent = 'Play Again';
  }, 380);
}

/* ===================== Loop ===================== */
let last=performance.now();
function loop(ts){
  const dt = Math.min(32, ts-last); last=ts;
  update(dt/16); render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===================== Update ===================== */
function update(dt){
  t += dt;

  if(state==='playing'){
    // physics
    bird.vy += G;
    bird.y  += bird.vy;
    bird.rot = Math.max(-MAX_ROT, Math.min(MAX_ROT, bird.vy*0.035));

    // scroll LEFT + update motion
    for(const p of pipes){ p.x -= speed; updatePipeMotion(p); }

    // recycle / spawn
    if(pipes.length && pipes[0].x + PIPE_W < -20){ pipes.shift(); }
    if(pipes.length < 4){
      const lastX = pipes.length? pipes[pipes.length-1].x : W + 200;
      spawnPipePair(lastX + DIST);
    }

    // scoring + speed-up + tempo ramp
    for(const p of pipes){
      const passedCenter = !p.passed && (p.x + PIPE_W < bird.x);
      if(passedCenter){
        p.passed = true; score++; AudioKit.point();
        speed = BASE_SPD + score*SPD_PER_PT;
        AudioKit.setTempoForScore(score);
        document.getElementById('scoreLive').textContent = score;
      }
    }

    // collisions
    if(bird.y + bird.h*0.5 > H - GROUND_H){ gameOver(); }
    for(const p of pipes){
      const gapY = p.gap;
      const topH = gapY - GAP/2;
      const botY = gapY + GAP/2;
      const botH = (H-GROUND_H) - botY;
      if(rectCircleCollide(p.x,0,PIPE_W,topH, bird.x,bird.y, bird.w*0.36)) gameOver();
      if(rectCircleCollide(p.x,botY,PIPE_W,botH, bird.x,bird.y, bird.w*0.36)) gameOver();
    }
  }

  // stars & flap puffs
  updateStars(dt);
  for(let i=puffs.length-1;i>=0;i--){
    const p=puffs[i]; p.x+=p.vx*6; p.y+=p.vy*6; p.a-=0.04; if(p.a<=0) puffs.splice(i,1);
  }
}

/* ===================== Render ===================== */
function render(){
  // night gradient
  const sky = ctx.createLinearGradient(0,0,0,H);
  sky.addColorStop(0,'#0c1a3d'); sky.addColorStop(1,'#040912');
  ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);

  // stars
  for(const s of stars){ drawStar(s); }

  // pipes + clefs
  for(const p of pipes){
    const gapY = p.gap;
    const topH = gapY - GAP/2;
    const botY = gapY + GAP/2;
    const botH = (H-GROUND_H) - botY;

    // draw exact rects
    drawPipeExact(p.x, 0, PIPE_W, topH, true);
    drawPipeExact(p.x, botY, PIPE_W, botH, false);

    // clefs: ensure they're inside the pipe rectangles (not the gap)
    drawClefOnRect(p.x, 0, PIPE_W, topH, p.topClef);
    drawClefOnRect(p.x, botY, PIPE_W, botH, p.botClef);
  }

  // ground
  ctx.fillStyle = '#0f3c15';
  ctx.fillRect(0,H-GROUND_H, W, GROUND_H);
  ctx.fillStyle = '#0b2c10';
  for(let i=0;i<W;i+=40){ ctx.fillRect(i, H-GROUND_H, 10, 14); }

  // flap puffs
  for(const p of puffs){
    ctx.save(); ctx.globalAlpha=Math.max(0,p.a); ctx.fillStyle='#cfe9ff';
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); ctx.restore();
  }

  // Frogzart ‚Äî facing LEFT
  drawFrog();
}

/* ===================== Drawing ===================== */
function drawFrog(){
  ctx.save();
  ctx.translate(bird.x, bird.y);
  ctx.scale(-1,1);                 // face left
  ctx.rotate(-bird.rot);           // reverse rotation because flipped
  const scaleY = 1 + (bird.vy>0?0.06:-0.04);
  ctx.scale(1, scaleY);
  if(frogImg.complete){
    ctx.drawImage(frogImg, 0,0, frogImg.width,frogImg.height, -bird.w/2, -bird.h/2, bird.w, bird.h);
  }else{
    ctx.fillStyle='#2b8a3e'; ctx.fillRect(-bird.w/2,-bird.h/2,bird.w,bird.h);
  }
  // shadow
  ctx.globalAlpha=.25; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(0, bird.h*.48, bird.w*.35, 12, 0, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* ===================== Collision Helpers ===================== */
function rectCircleCollide(rx,ry,rw,rh, cx,cy, cr){
  const closestX = clamp(cx, rx, rx+rw);
  const closestY = clamp(cy, ry, ry+rh);
  const dx = cx - closestX, dy = cy - closestY;
  return (dx*dx + dy*dy) < (cr*cr);
}
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ===================== Boot ===================== */
function showStart(){
  document.getElementById('overlay').style.display='flex';
  document.getElementById('scoreLive').textContent = 0;
}
showStart();

AudioKit.init(); // sound starts after first click
document.getElementById('play').addEventListener('click', ()=>AudioKit.startMusic(), {once:true});
</script>
</body>
</html>